WEBVTT

00:00:05.210 --> 00:00:07.990
>> 好的，處理條件判斷

00:00:07.990 --> 00:00:09.860
我還有最後一組技巧
可以分享給你

00:00:09.860 --> 00:00:11.799
在做條件判斷時

00:00:11.799 --> 00:00:13.660
可能有各種不同的變化

00:00:13.660 --> 00:00:16.345
所以我還有幾個技巧
想分享給你

00:00:16.345 --> 00:00:19.030
有時你可以結合
條件判斷與

00:00:19.030 --> 00:00:21.310
"and"運算子
而不使用巢狀"if"述句

00:00:21.310 --> 00:00:23.935
這次我們用另一個
生活中的例子

00:00:23.935 --> 00:00:26.260
假設你是一所大學或

00:00:26.260 --> 00:00:27.400
一所大學的老師

00:00:27.400 --> 00:00:29.485
你試圖計算哪些學生

00:00:29.485 --> 00:00:31.270
可以登上榮譽榜

00:00:31.270 --> 00:00:33.265
通常要登上榮譽榜

00:00:33.265 --> 00:00:34.930
學習成績的平均

00:00:34.930 --> 00:00:36.885
要達到一定水準

00:00:36.885 --> 00:00:38.560
但它也可能要求

00:00:38.560 --> 00:00:41.575
所有學科的成績
都要高於一定的水準

00:00:41.575 --> 00:00:43.120
所以你的最低分不能

00:00:43.120 --> 00:00:44.540
低於全班的 70%

00:00:44.540 --> 00:00:47.285
而且你的總平均必須
高於全班的 85%

00:00:47.285 --> 00:00:50.660
所以我用巢狀"if"述句
可以做到這一點

00:00:50.660 --> 00:00:52.485
我們已經學會了
如何用巢狀"if"述句

00:00:52.485 --> 00:00:53.940
我說，如果總平均

00:00:53.940 --> 00:00:57.240
高於或等於 0.85

00:00:57.240 --> 00:01:01.055
然後讓我們檢查
你的最低分數

00:01:01.055 --> 00:01:03.760
如果你的最低成績是
大於等於 0.7

00:01:03.760 --> 00:01:05.820
那麼這意味著你已經
滿足這兩個要求

00:01:05.820 --> 00:01:07.640
幹得好
你已經進了榮譽榜

00:01:07.640 --> 00:01:09.770
但我可以使用"and"運算子

00:01:09.770 --> 00:01:11.390
重寫這段程式

00:01:11.390 --> 00:01:13.580
因為這兩個要求

00:01:13.580 --> 00:01:14.990
都必須要達到

00:01:14.990 --> 00:01:16.475
才能進入榮譽榜

00:01:16.475 --> 00:01:17.900
缺一不可

00:01:17.900 --> 00:01:19.160
所以我可以簡單地說

00:01:19.160 --> 00:01:21.890
如果總平均超過 85% 而且

00:01:21.890 --> 00:01:23.700
你的最低學科分數

00:01:23.700 --> 00:01:25.625
大於或等於 70%

00:01:25.625 --> 00:01:26.810
那就表示你已經
進了榮譽榜

00:01:26.810 --> 00:01:28.910
這樣寫會更容易讀懂

00:01:28.910 --> 00:01:30.770
也沒有那麼多次的縮排

00:01:30.770 --> 00:01:33.215
因此

00:01:33.215 --> 00:01:35.240
因此它也減少

00:01:35.240 --> 00:01:37.910
在縮排上犯錯的機會

00:01:37.910 --> 00:01:41.030
"and"運算子
的運算方式是

00:01:41.030 --> 00:01:42.440
前後兩個條件必須為真

00:01:42.440 --> 00:01:45.440
結果才會被評估為真

00:01:45.440 --> 00:01:47.449
所以在這個範例中

00:01:47.449 --> 00:01:50.750
如果我們的總平均沒超過 85%

00:01:50.750 --> 00:01:53.540
假設你的總平均是 70%

00:01:53.540 --> 00:01:56.120
那你就進不了
榮譽榜

00:01:56.120 --> 00:01:57.420
如果你的最低
分學科是 60%

00:01:57.420 --> 00:01:59.495
你也不進不了
榮譽榜

00:01:59.495 --> 00:02:01.640
因此有一個條件
滿足是不夠的

00:02:01.640 --> 00:02:03.920
要兩個條件都滿足

00:02:03.920 --> 00:02:06.035
這一行的條件
才會被當作成立

00:02:06.035 --> 00:02:09.300
然後執行下一行：
輸出"Well done"

00:02:10.030 --> 00:02:13.130
另外還有一個巧妙的技巧

00:02:13.130 --> 00:02:15.935
特別是當你的"if"述句
真的很複雜的時候

00:02:15.935 --> 00:02:19.325
設一個旗標儲存布林值
會相當有用

00:02:19.325 --> 00:02:20.990
在你的程式裡
可能有多個地方

00:02:20.990 --> 00:02:22.955
都需要用到這次
條件判斷的結果

00:02:22.955 --> 00:02:26.690
比起重複寫
相同"if"述句

00:02:26.690 --> 00:02:28.760
特別是如果這個
條件判斷很複雜

00:02:28.760 --> 00:02:31.400
你擔心你可能會寫錯
或者只是為了可讀性

00:02:31.400 --> 00:02:33.800
你可以宣告一個
布林值旗標

00:02:33.800 --> 00:02:37.340
來儲存這次"if"
條件判斷的結果

00:02:37.340 --> 00:02:39.350
所以在這個範例中
我可以說："嘿，

00:02:39.350 --> 00:02:43.295
讓我們檢查總平均和
最低分數是否符合要求

00:02:43.295 --> 00:02:45.440
如果是我就宣告
一個變數並賦值

00:02:45.440 --> 00:02:47.905
變數名稱為"honour_roll"
並將其設為 True

00:02:47.905 --> 00:02:50.430
在Python中
當它看到 True 時

00:02:50.430 --> 00:02:53.530
前後沒有引號的 True

00:02:53.530 --> 00:02:55.850
這實際上是Python
中的一個關鍵字

00:02:55.850 --> 00:02:58.250
這使得這個變數成為
一個布林值得變數

00:02:58.250 --> 00:03:01.280
布林值只可能等於 True
或等於 False

00:03:01.280 --> 00:03:03.110
所以我說，如果條件成立

00:03:03.110 --> 00:03:04.970
將"honour_roll"設為 True

00:03:04.970 --> 00:03:06.275
否則將"honour_roll"設為 False

00:03:06.275 --> 00:03:08.720
然後之後在你的程式中

00:03:08.720 --> 00:03:11.070
當你需要這個結果時

00:03:11.070 --> 00:03:12.785
例如，如果他們
在榮譽榜上

00:03:12.785 --> 00:03:15.125
就需要發送
祝賀信件給他們

00:03:15.125 --> 00:03:16.965
我只要說
如果"honour_roll"為真

00:03:16.965 --> 00:03:20.615
就輸出"做得好"
或列印給他們的祝賀信件

00:03:20.615 --> 00:03:24.290
所以我不必重寫
整段複雜的邏輯

00:03:24.290 --> 00:03:27.650
順便說一下
你有時會看到程式寫

00:03:27.650 --> 00:03:31.680
"if honour_roll == True:"
其實你在Python中不需要這樣做

00:03:31.680 --> 00:03:34.510
你只需要寫
"if honour_roll:"

00:03:34.510 --> 00:03:38.035
因為"honour_roll"
本身就是 True 或 False

00:03:38.035 --> 00:03:40.875
因此，在Python
的語言標種中

00:03:40.875 --> 00:03:42.230
你可以只寫"if honour_roll:"

00:03:42.230 --> 00:03:44.315
而不用寫
"if honour_roll == True"

00:03:44.315 --> 00:03:48.090
雖然兩者都能用
但前者是慣例

00:03:48.100 --> 00:03:52.580
所以現在我們有一些新的選擇
和許多不同的方式

00:03:52.580 --> 00:03:53.990
來處理非常複雜的
程式中的條件判斷

00:03:53.990 --> 00:03:56.080
我知道我以前說過

00:03:56.080 --> 00:03:58.355
但我要再說一遍
因為重要的事要說三遍

00:03:58.355 --> 00:04:00.485
當你開始寫
複雜的條件判斷

00:04:00.485 --> 00:04:02.390
務必做好你的單元測試

00:04:02.390 --> 00:04:04.910
要測試所有
可能的條件組合

00:04:04.910 --> 00:04:08.130
否則很容易會有Bug

