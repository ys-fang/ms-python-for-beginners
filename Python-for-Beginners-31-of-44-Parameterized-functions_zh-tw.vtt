WEBVTT

00:00:04.040 --> 00:00:07.335
>> 你已經瞭解了如何創建基本函數

00:00:07.335 --> 00:00:10.140
讓我們來看看如何操作

00:00:10.140 --> 00:00:11.430
傳遞進函數的參數

00:00:11.430 --> 00:00:13.770
有幾件事值得深入探討

00:00:13.770 --> 00:00:16.800
你已經知道

00:00:16.800 --> 00:00:19.545
函數可以接收參數
也可以傳回值

00:00:19.545 --> 00:00:20.910
我們再複習一下

00:00:20.910 --> 00:00:23.445
我們創建了一個函數
名為"get_initial()"

00:00:23.445 --> 00:00:25.800
當你呼叫"get_initial()"
的時候要傳遞了一個參數

00:00:25.800 --> 00:00:28.020
所以在這裡我們呼叫

00:00:28.020 --> 00:00:30.330
函數"get_initial()"
並傳遞"first_name"作為參數

00:00:30.330 --> 00:00:32.900
傳給函數的值

00:00:32.900 --> 00:00:34.670
在函數中被當作
變數"name"來中使用

00:00:34.670 --> 00:00:37.175
當函數執行完
它回傳一個值

00:00:37.175 --> 00:00:39.260
然後我要有個地方

00:00:39.260 --> 00:00:41.405
來儲存回傳的值

00:00:41.405 --> 00:00:43.490
因此在這個範例中
當函數回傳"initial"

00:00:43.490 --> 00:00:46.010
我從函數收到這個值

00:00:46.010 --> 00:00:49.195
就把值放到名為
"first_name_initial"的變數中

00:00:49.195 --> 00:00:50.930
好的，我寫完程式後

00:00:50.930 --> 00:00:53.450
才想到一件事

00:00:53.450 --> 00:00:56.440
也許如果有人會用小寫
輸入他們的名字

00:00:56.440 --> 00:00:58.010
但我希望取得的字首縮寫

00:00:58.010 --> 00:00:59.810
是大寫字母

00:00:59.810 --> 00:01:03.720
可能之後會用來當作登入帳號
或電子郵件帳號之類的

00:01:03.720 --> 00:01:06.515
所以我添加了".upper()"

00:01:06.515 --> 00:01:09.445
確保"initial"變數是大寫

00:01:09.445 --> 00:01:11.780
我覺得帳號名稱

00:01:11.780 --> 00:01:14.120
用字首縮寫很合理

00:01:14.120 --> 00:01:15.895
但如果是電子郵件帳號呢？

00:01:15.895 --> 00:01:18.815
電子郵件帳號

00:01:18.815 --> 00:01:20.660
應該都是小寫字母

00:01:20.660 --> 00:01:22.310
所以有時我需要大寫

00:01:22.310 --> 00:01:23.915
所以有時我需要小寫

00:01:23.915 --> 00:01:26.315
那怎麼辦？沒關係
因為我能透過

00:01:26.315 --> 00:01:29.045
為函數加上多個參數
解決這個問題

00:01:29.045 --> 00:01:32.675
我加了第二個參數

00:01:32.675 --> 00:01:36.725
名為"force_uppercase"

00:01:36.725 --> 00:01:40.700
當我呼叫這個函數時

00:01:40.700 --> 00:01:42.880
可以說"否"，不要轉換成大寫

00:01:42.880 --> 00:01:46.660
或"是"，要強制轉換成大寫

00:01:46.660 --> 00:01:50.360
然後在函數中，如果我接收到的
參數是"是"

00:01:50.360 --> 00:01:52.385
就將"initial"轉成大寫再回傳

00:01:52.385 --> 00:01:54.800
否則就不用轉成大寫

00:01:54.800 --> 00:01:58.220
你可以傳遞給函數多個參數

00:01:58.220 --> 00:02:00.790
但要確保如果你有多個參數

00:02:00.790 --> 00:02:03.920
傳遞參數的順序要跟
函數宣告時的參數順序一樣

00:02:03.920 --> 00:02:06.800
所以你會注意到我有參數
"name"和"force_uppercase"

00:02:06.800 --> 00:02:09.470
當我呼叫它時

00:02:09.470 --> 00:02:12.450
我傳遞一個名字

00:02:12.450 --> 00:02:15.590
和一個布林值，也就是參數
"force_uppercase"的值

00:02:15.590 --> 00:02:17.750
所以現在我能更靈活的

00:02:17.750 --> 00:02:19.750
的使用函數

00:02:19.750 --> 00:02:22.840
但這也帶了一些麻煩

00:02:22.840 --> 00:02:25.340
包括有幾個參數、
參數的順序等等

00:02:25.340 --> 00:02:27.325
因此我們要
再多介紹一些技巧

00:02:27.325 --> 00:02:29.500
我們可以

00:02:29.500 --> 00:02:32.320
指定參數的預設值

00:02:32.320 --> 00:02:34.720
這樣做很聰明

00:02:34.720 --> 00:02:36.400
因為可能大多數時候

00:02:36.400 --> 00:02:38.365
你希望回傳的是
大寫的字首縮寫

00:02:38.365 --> 00:02:40.750
所以我可以指定

00:02:40.750 --> 00:02:44.155
"force_uppercase"的
預設值為"True"

00:02:44.155 --> 00:02:46.390
這意味著如果你不給我一個

00:02:46.390 --> 00:02:48.540
"force_uppercase"的值

00:02:48.540 --> 00:02:51.565
"force_uppercase"
就預設為"True"

00:02:51.565 --> 00:02:55.450
在這的範例中我呼叫函數

00:02:55.450 --> 00:02:57.865
你看到我甚至沒有給
"force_uppercase"的值

00:02:57.865 --> 00:02:59.920
如果我想，我可以傳遞一個值

00:02:59.920 --> 00:03:01.270
我可以傳遞"True"

00:03:01.270 --> 00:03:04.525
我也可以傳遞"False"

00:03:04.525 --> 00:03:06.260
或者我也可以就只給你一個名字

00:03:06.260 --> 00:03:08.465
反正你知道第二個參數
預設該怎麼辦

00:03:08.465 --> 00:03:10.190
這是另一個
你可能會在很多部落格或教學文章

00:03:10.190 --> 00:03:12.260
看到的寫法

00:03:12.260 --> 00:03:14.440
你可能會覺得奇怪
為什麼他們呼叫某個函數

00:03:14.440 --> 00:03:17.510
要傳遞四個或五個值
但當我呼叫它的時候

00:03:17.510 --> 00:03:18.830
我只傳遞了一個值

00:03:18.830 --> 00:03:20.330
這是怎麼回事？

00:03:20.330 --> 00:03:22.190
這是因為寫這個函數的人

00:03:22.190 --> 00:03:24.500
對某些參數
有設定預設值

00:03:24.500 --> 00:03:26.930
而那些預設值

00:03:26.930 --> 00:03:29.630
適用於當時的情況

00:03:29.630 --> 00:03:31.640
因此，當你指定參數時

00:03:31.640 --> 00:03:34.159
記得要去查找
該函數的說明文件

00:03:34.159 --> 00:03:37.235
查看一些參數
是否具有預設值

00:03:37.235 --> 00:03:39.560
如果他們這樣做，這意味著你不是

00:03:39.560 --> 00:03:42.810
非傳遞一個值不可
也就是該參數是「可選的」

00:03:44.870 --> 00:03:47.680
另外還有

00:03:47.680 --> 00:03:49.960
一個好習慣可以學起來

00:03:49.960 --> 00:03:51.715
可以增加你程式的可讀性

00:03:51.715 --> 00:03:54.550
就是名稱記號(Named Notation)

00:03:54.550 --> 00:03:56.260
在前面我說你必須

00:03:56.260 --> 00:03:58.675
按順序傳遞參數
按照他們被宣告的順序

00:03:58.675 --> 00:04:01.435
所以如果我參數的順序是
"name, force_uppercase"

00:04:01.435 --> 00:04:02.920
我就必須先傳遞"name"的值

00:04:02.920 --> 00:04:05.050
然後才是"force_uppercase"的值

00:04:05.050 --> 00:04:07.075
但這個說法不完全正確

00:04:07.075 --> 00:04:10.060
因為如果使用名稱記號

00:04:10.060 --> 00:04:11.875
次序就無所謂了

00:04:11.875 --> 00:04:14.980
因為函數知道哪個值

00:04:14.980 --> 00:04:16.375
是給哪一個參數的

00:04:16.375 --> 00:04:19.045
在這裡使用名稱記號

00:04:19.045 --> 00:04:21.960
就是呼叫函數時

00:04:21.960 --> 00:04:24.395
指定

00:04:24.395 --> 00:04:26.490
"force_uppercase = True"

00:04:26.490 --> 00:04:28.100
而

00:04:28.100 --> 00:04:30.530
"name = first_name"

00:04:30.530 --> 00:04:31.850
所以在這個範例中

00:04:31.850 --> 00:04:33.350
因為我有明確的

00:04:33.350 --> 00:04:35.870
告訴函數

00:04:35.870 --> 00:04:38.630
哪個值是給"name"

00:04:38.630 --> 00:04:40.235
哪個值是給"force_uppercase"

00:04:40.235 --> 00:04:41.880
所以通過名稱記號

00:04:41.880 --> 00:04:44.555
參數的順序就不重要了

00:04:44.555 --> 00:04:48.665
而我當然還是可以

00:04:48.665 --> 00:04:50.240
設定參數的預設值

00:04:50.240 --> 00:04:52.180
它們仍然是可選的

00:04:52.180 --> 00:04:54.605
我喜歡這樣做

00:04:54.605 --> 00:04:56.390
雖然執行的結果是完全一樣的

00:04:56.390 --> 00:04:58.715
但這樣做會讓程式碼
閱讀起來變得容易得多

00:04:58.715 --> 00:05:01.520
我曾經做過很多系統

00:05:01.520 --> 00:05:03.980
當在程式中出現了問題
我們不得不記錄錯誤時


00:05:03.980 --> 00:05:07.090
你有時會看到
這樣的程式碼

00:05:07.090 --> 00:05:10.040
曾經有一個我們的團隊的
工程師寫了這樣一個函數

00:05:10.040 --> 00:05:12.935
函數會接收
傳遞錯誤訊息和錯誤代碼

00:05:12.935 --> 00:05:14.420
以及錯誤嚴重程度

00:05:14.420 --> 00:05:16.730
等等這些參數
然後會在螢幕上

00:05:16.730 --> 00:05:18.215
輸出錯誤訊息

00:05:18.215 --> 00:05:20.750
然後把錯誤紀錄到資料庫

00:05:20.750 --> 00:05:23.720
以及後續一些處理

00:05:23.720 --> 00:05:26.240
你會程式中這樣呼叫

00:05:26.240 --> 00:05:28.545
呼叫"error_logger()"

00:05:28.545 --> 00:05:32.180
傳遞了幾個值
"45, 1, True..."

00:05:32.180 --> 00:05:34.810
"Second number greater 
than first my map method."

00:05:34.810 --> 00:05:36.835
好吧~~ (譯註：函數跟呼叫函數的述句
很可能在不同檔案中)

00:05:36.835 --> 00:05:39.635
我不確定這些值
代表甚麼意思

00:05:39.635 --> 00:05:41.420
我只能猜他們是正確的

00:05:41.420 --> 00:05:44.750
如果一段時間之後
我被要求去改這個人的程式碼

00:05:44.750 --> 00:05:47.300
當我讀到這樣一句話
我會非常困惑

00:05:47.300 --> 00:05:49.435
那我可以如何改寫呢？

00:05:49.435 --> 00:05:51.140
我使用名稱記號

00:05:51.140 --> 00:05:54.755
在這裡它說呼叫
"error_logger()"

00:05:54.755 --> 00:05:58.700
傳遞"error_code = 45"
"error_severity = 1"

00:05:58.700 --> 00:06:01.215
"log_to_db = True"

00:06:01.215 --> 00:06:03.410
"error_message =
'second number greater than first'"

00:06:03.410 --> 00:06:07.200
"source_module = 'my_math_method'"

00:06:07.240 --> 00:06:11.540
這樣一來我就
大概能猜出

00:06:11.540 --> 00:06:13.250
我傳遞進"error_logger"函數的

00:06:13.250 --> 00:06:15.830
這幾個參數是甚麼意思

00:06:15.830 --> 00:06:17.870
這是一個非常有用的技巧

00:06:17.870 --> 00:06:19.910
讓你的程式碼
更易於閱讀

00:06:19.910 --> 00:06:21.920
讓不論是讓你自己
在幾個月之後

00:06:21.920 --> 00:06:24.200
或別人能更加
理解你當時是怎麼想的

00:06:24.200 --> 00:06:27.980
因此，名稱記號能讓
你的代碼更具可讀性

00:06:27.980 --> 00:06:31.590
讓我們在下一單元
一步一步來實作

