WEBVTT

00:00:04.100 --> 00:00:07.050
>> 好的，讓我們直接看程式

00:00:07.050 --> 00:00:09.510
看看在程式中怎麼使用日期

00:00:09.510 --> 00:00:11.820
這個程式

00:00:11.820 --> 00:00:12.990
首先要取得

00:00:12.990 --> 00:00:15.030
目前的日期和時間

00:00:15.030 --> 00:00:16.950
所以，你會看到這裡有一行

00:00:16.950 --> 00:00:19.320
從"datetime"函式庫
匯入"datetime"模組

00:00:19.320 --> 00:00:21.510
我們後面的章節才會
深入介紹函式庫

00:00:21.510 --> 00:00:23.625
現在搞不懂這行沒關係

00:00:23.625 --> 00:00:25.649
這基本上就只是說

00:00:25.649 --> 00:00:27.270
嘿，那裏有一個
很酷的"datetime"模組

00:00:27.270 --> 00:00:29.115
是別人為我寫的

00:00:29.115 --> 00:00:31.020
我想用它，它就在那個函式庫裡
(譯註：這個函式庫的名字也叫"datetime")

00:00:31.020 --> 00:00:32.670
所以這行程式讓我
在我自己程式中

00:00:32.670 --> 00:00:35.295
可以使用別人寫好的程式碼

00:00:35.295 --> 00:00:38.610
接下來這行的"datetime.now()"
就是別人寫的函數

00:00:38.610 --> 00:00:41.475
所以我做的是就呼叫這個
"datetime"模組中的"now()"函數

00:00:41.475 --> 00:00:42.810
這將傳回目前的日期

00:00:42.810 --> 00:00:46.205
然後我將它儲存在變數內部

00:00:46.205 --> 00:00:48.500
所以現在我有這個
"current_date"變數

00:00:48.500 --> 00:00:50.585
裡面的值是
目前的日期和時間

00:00:50.585 --> 00:00:52.565
然後我寫一行
"print"述句

00:00:52.565 --> 00:00:54.485
讓我們先很簡單的

00:00:54.485 --> 00:00:56.404
只輸出"current_date"

00:00:56.404 --> 00:00:58.160
只是為了讓你看看
會發生甚麼事

00:00:58.160 --> 00:01:02.270
執行看看

00:01:02.270 --> 00:01:09.650
"python get_current_date.py"
然後它就爆炸了

00:01:09.650 --> 00:01:12.440
記得我們之前講過的
資料型別和型別轉換嗎？

00:01:12.440 --> 00:01:14.495
當你在處理日期
一樣會遇到型別的問題

00:01:14.495 --> 00:01:15.850
現在它就發生了

00:01:15.850 --> 00:01:17.025
我們看到一個錯誤

00:01:17.025 --> 00:01:18.665
說我只能串接字串

00:01:18.665 --> 00:01:21.200
它不知道怎麼串接"datetime"

00:01:21.200 --> 00:01:25.610
是的，我真的不知道6月5日
加上蘇珊等於什麼

00:01:25.610 --> 00:01:27.065
Python也不知道

00:01:27.065 --> 00:01:28.730
所以我們必須做的是

00:01:28.730 --> 00:01:30.485
就像我們處理數字

00:01:30.485 --> 00:01:33.305
我們必須轉換日期成字串

00:01:33.305 --> 00:01:35.300
因為Python確實知道

00:01:35.300 --> 00:01:37.595
如何串接字串和字串

00:01:37.595 --> 00:01:39.970
所以通過型別轉換成字串

00:01:39.970 --> 00:01:42.845
現在我成功地得到了
"Today is: 2019-06-10..."

00:01:42.845 --> 00:01:44.450
現在被你知道一個秘密了

00:01:44.450 --> 00:01:48.530
你現在知道蘇珊
在6月10日錄了這支影片

00:01:48.530 --> 00:01:51.035
不管你什麼時候
觀看這支影片

00:01:51.035 --> 00:01:55.250
一但你有一個變數

00:01:55.250 --> 00:01:57.140
裡面儲存的值是
"datetime"型別

00:01:57.140 --> 00:01:59.240
那你就能使用能
操作這個型別的函數

00:01:59.240 --> 00:02:01.265
而很多函數真的很神奇

00:02:01.265 --> 00:02:03.620
所以我現在所做的是

00:02:03.620 --> 00:02:05.510
匯入了另一個函數

00:02:05.510 --> 00:02:07.505
在程式一開始的地方匯入
下面的程式就能使用

00:02:07.505 --> 00:02:09.080
所以我仍然匯入"datetime"

00:02:09.080 --> 00:02:11.615
但加一個"timedelta"

00:02:11.615 --> 00:02:13.700
這是一很簡潔的函數

00:02:13.700 --> 00:02:17.150
讓我可以指定一個時間差

00:02:17.150 --> 00:02:18.900
x 天、或五天、三天

00:02:18.900 --> 00:02:21.585
一周、六周等等

00:02:21.585 --> 00:02:23.265
現在我們重新寫一個程式

00:02:23.265 --> 00:02:25.065
一樣先取得
目前的日期和時間

00:02:25.065 --> 00:02:27.650
我把它放在名為
"today"的變數中

00:02:27.650 --> 00:02:29.600
然後把它輸出到螢幕

00:02:29.600 --> 00:02:31.340
這跟我們剛才執行的程式差不多

00:02:31.340 --> 00:02:33.425
但這是一個新的程式

00:02:33.425 --> 00:02:35.525
這次我們會用
"timedelta"函數

00:02:35.525 --> 00:02:37.880
產生一個一天長度的時間差

00:02:37.880 --> 00:02:39.965
所以我寫"one_day = "

00:02:39.965 --> 00:02:41.600
"timedelta(days=1)"

00:02:41.600 --> 00:02:43.170
"days=1"是一個
傳入的參數

00:02:43.170 --> 00:02:44.630
我從網上關於"timedelta"函數
的說明文件

00:02:44.630 --> 00:02:47.060
查到參數要怎麼寫

00:02:47.060 --> 00:02:48.260
你也一樣可以查到
如何把這個參數值

00:02:48.260 --> 00:02:50.180
變成以禮拜或月為單位

00:02:50.180 --> 00:02:51.200
你一定要去看看

00:02:51.200 --> 00:02:53.680
"timedelta"的線上說明文件

00:02:53.680 --> 00:02:56.150
現在我可以簡單的寫

00:02:56.150 --> 00:02:59.885
yesterday = today - one_day

00:02:59.885 --> 00:03:02.180
這其實在做對日期做數學運算

00:03:02.180 --> 00:03:05.960
然後輸出結果到螢幕上

00:03:05.960 --> 00:03:08.585
我把下面這幾行註解掉

00:03:08.585 --> 00:03:11.855
好讓它看起來簡單一點

00:03:11.855 --> 00:03:15.215
現在執行這個程式

00:03:15.215 --> 00:03:22.770
"python date_functions.py"

00:03:22.770 --> 00:03:24.555
你可以看到結果就是 9

00:03:24.555 --> 00:03:26.790
在 6 月 10 日執行此程式

00:03:26.790 --> 00:03:29.325
而昨天是 6 月 9 日

00:03:29.325 --> 00:03:31.580
這種能夠減去或增加
時間差的功能

00:03:31.580 --> 00:03:34.580
其實是非常強大的

00:03:34.580 --> 00:03:36.860
我曾經用Cobol語言

00:03:36.860 --> 00:03:39.790
寫過一個模組
用了1500行程式碼

00:03:39.790 --> 00:03:42.530
基本上就是轉換
儒略曆為格里曆

00:03:42.530 --> 00:03:44.000
還要考慮哪幾年是閏年

00:03:44.000 --> 00:03:45.725
等等的問題

00:03:45.725 --> 00:03:47.090
所以事實上

00:03:47.090 --> 00:03:48.860
有一個函數能幫我們
解決這些麻煩問題

00:03:48.860 --> 00:03:50.810
對我們在處理日期運算上

00:03:50.810 --> 00:03:53.035
是一個非常大
非常有用的幫助

00:03:53.035 --> 00:03:55.470
讓我們回到程式
我想告訴你

00:03:55.470 --> 00:03:57.390
時間差不只可以用天算

00:03:57.390 --> 00:03:59.950
在這裡
我寫"days=1"

00:03:59.950 --> 00:04:04.300
我先把這幾行註解掉

00:04:04.300 --> 00:04:06.290
在這行我改寫成

00:04:06.290 --> 00:04:08.240
如果我們減去一個星期呢？

00:04:08.240 --> 00:04:10.160
所以當我呼叫"timedelta"函數

00:04:10.160 --> 00:04:12.340
我要求它產生一個星期的時間差

00:04:12.340 --> 00:04:14.705
然後我從今天減去一個星期

00:04:14.705 --> 00:04:19.590
重新執行程式

00:04:19.840 --> 00:04:22.535
我們可以看到結果變成

00:04:22.535 --> 00:04:24.080
如果今天是十號

00:04:24.080 --> 00:04:25.775
而一個星期前是六月三日

00:04:25.775 --> 00:04:28.040
所以它會處理所有的問題

00:04:28.040 --> 00:04:30.230
像是本月有30天或31天？

00:04:30.230 --> 00:04:31.370
是閏年嗎？

00:04:31.370 --> 00:04:33.320
這些都幫我處理好了

00:04:33.320 --> 00:04:35.540
因此，"timedelta"是
一個簡潔函數的例子

00:04:35.540 --> 00:04:37.525
這樣的函數可以幫你處理日期

00:04:37.525 --> 00:04:38.815
而這樣的函數
在函數庫裡還有很多

00:04:38.815 --> 00:04:40.420
所以如果你想處理日期

00:04:40.420 --> 00:04:41.895
在開始自己從頭開始寫之前

00:04:41.895 --> 00:04:43.490
先查一下線上說明文件

00:04:43.490 --> 00:04:45.760
你可能可以找到一個合用的函數
(譯註：而不用自己重新發明輪子)

00:04:45.760 --> 00:04:48.930
現在，當你要顯示日期給別人看

00:04:48.930 --> 00:04:50.300
你可能需要格式化它

00:04:50.300 --> 00:04:52.430
你可能並不是每次
都需要完整的日期

00:04:52.430 --> 00:04:54.875
包含小時、分鐘、秒和毫秒等等

00:04:54.875 --> 00:04:57.370
所以我們回頭來看這支程式

00:04:57.370 --> 00:04:58.940
我在這裡所做的是

00:04:58.940 --> 00:05:00.830
我實際上只提取日期中

00:05:00.830 --> 00:05:02.360
我感興趣的部分

00:05:02.360 --> 00:05:05.825
我重新開始說
我想使用"datetime"模組

00:05:05.825 --> 00:05:08.120
在"datetime"函式庫中
所以這是一個很棒的功能

00:05:08.120 --> 00:05:11.610
我用"datetime.now()"
取得目前的日期和時間

00:05:11.610 --> 00:05:13.890
儲存在名為"today"的變數中

00:05:13.890 --> 00:05:15.750
接下來

00:05:15.750 --> 00:05:17.340
我用"today.day"

00:05:17.340 --> 00:05:19.470
它將只回傳日期(幾號)

00:05:19.470 --> 00:05:21.740
"today.month"則會傳回月份

00:05:21.740 --> 00:05:24.515
year傳回年、
hour傳回小時，等等

00:05:24.515 --> 00:05:26.090
那麼我可以擷取這些值

00:05:26.090 --> 00:05:29.640
然後把它們輸出到螢幕上

00:05:29.640 --> 00:05:33.600
所以我可以存取
日期的任何部分

00:05:33.600 --> 00:05:36.680
不用每次都一定要
顯示完整日期

00:05:36.680 --> 00:05:38.480
你可以只提取並使用

00:05:38.480 --> 00:05:41.380
你感興趣的部分

00:05:41.380 --> 00:05:44.990
有時當你處理日期

00:05:44.990 --> 00:05:47.150
你會遇到一些有趣的麻煩事

00:05:47.150 --> 00:05:50.660
假設你要從檔案、資料庫
或使用者輸入

00:05:50.660 --> 00:05:53.380
讀取一個值

00:05:53.380 --> 00:05:55.520
不幸的是
大多數的狀況

00:05:55.520 --> 00:05:57.695
你從檔案、資料庫、
或使用者輸入

00:05:57.695 --> 00:05:59.900
取得的值

00:05:59.900 --> 00:06:02.605
被Python讀取時
都會被視為字串

00:06:02.605 --> 00:06:05.764
但如果我想使用
這些很酷的日期函數

00:06:05.764 --> 00:06:08.945
只能先把它轉換成
"datetime"資料型別

00:06:08.945 --> 00:06:12.020
所以再一次
我又要做資料型別轉換

00:06:12.020 --> 00:06:15.355
現在我需要轉換字串為日期

00:06:15.355 --> 00:06:19.160
但我怎麼知道拿到的值是

00:06:19.160 --> 00:06:22.615
日-月-年或月-天-年？

00:06:22.615 --> 00:06:24.705
你用斜線還是連字號？

00:06:24.705 --> 00:06:26.525
等等這些
需要額外處理的麻煩事

00:06:26.525 --> 00:06:28.970
所以在這個範例中

00:06:28.970 --> 00:06:31.715
我要取得一個字串
並將其轉換為日期

00:06:31.715 --> 00:06:34.880
我在要求使用者
輸入他們的生日的時候

00:06:34.880 --> 00:06:37.830
我提示使用者

00:06:37.830 --> 00:06:40.000
"拜託給我這種格式的日期"

00:06:40.000 --> 00:06:41.780
使用者可能不甩你

00:06:41.780 --> 00:06:44.630
但至少我有提醒
並提供我預期的正確的格式

00:06:44.630 --> 00:06:46.190
接下來

00:06:46.190 --> 00:06:48.545
我使用"strptime"函數

00:06:48.545 --> 00:06:51.710
這個函數在做什麼呢？

00:06:51.710 --> 00:06:55.535
它會從字串剝離出日期元素
並轉換為"datetime"格式

00:06:55.535 --> 00:06:57.310
所以這個字串

00:06:57.310 --> 00:07:00.680
包含了某人鍵入的生日字串

00:07:00.680 --> 00:07:02.270
然後必須告訴"strptime"函數

00:07:02.270 --> 00:07:04.505
將給他甚麼格式的日期

00:07:04.505 --> 00:07:06.920
"%d"代表日期、%m%代表月份

00:07:06.920 --> 00:07:09.170
然後"%Y" (譯註：注意這裡Y是大寫喔)

00:07:09.170 --> 00:07:10.415
代表四位數的年份

00:07:10.415 --> 00:07:12.200
我怎麼知道這些參數？

00:07:12.200 --> 00:07:16.105
我查了"strptime"函數的
線上說明文件

00:07:16.105 --> 00:07:19.300
查文件就是
學習函數語法的方法

00:07:19.300 --> 00:07:23.270
然後我可以
在螢幕上輸出一個值

00:07:23.270 --> 00:07:25.400
然後使用"timedelta"函數

00:07:25.400 --> 00:07:27.815
算出我生日的前一天是幾月幾號

00:07:27.815 --> 00:07:30.730
好，讓我們實際試看看

00:07:30.730 --> 00:07:33.110
執行

00:07:33.110 --> 00:07:35.360
它提示我輸入日期

00:07:35.360 --> 00:07:36.575
我的生日是什麼時候？

00:07:36.575 --> 00:07:38.840
日、月、年

00:07:38.840 --> 00:07:41.630
我的生日假設是
1999年6月6日

00:07:41.630 --> 00:07:48.055
繼續執行
它說你的生日是六月十日

00:07:48.055 --> 00:07:50.375
而你生日的前一天是六月五日

00:07:50.375 --> 00:07:52.295
所以你可以看到

00:07:52.295 --> 00:07:54.170
我已經成功轉換成日期型別

00:07:54.170 --> 00:07:58.280
因為我可以使用那些"datetime"模組
中的函數，例如"timedelta"

00:07:58.280 --> 00:08:01.760
但是如果使用者執行你的程式時

00:08:01.760 --> 00:08:05.025
沒注意到你提示的格式呢？

00:08:05.025 --> 00:08:06.885
"我的生日什麼時候？"

00:08:06.885 --> 00:08:09.810
他們說："是2月30號"

00:08:09.810 --> 00:08:12.520
或者他們確實輸入了有效日期

00:08:12.520 --> 00:08:14.810
但他們進入連字號
而不是斜線

00:08:14.810 --> 00:08:18.630
例如"06-10-1999"

00:08:19.180 --> 00:08:22.460
他們輸入格式不對的東西

00:08:22.460 --> 00:08:25.430
不符合我提示的格式

00:08:25.430 --> 00:08:29.630
所以執行到這裡就爆炸了

00:08:29.630 --> 00:08:32.150
這是一種顯然可以預知到

00:08:32.150 --> 00:08:34.400
不時會發生的例外狀況

00:08:34.400 --> 00:08:37.385
所以在這裡
你應該要加入一些例外處理

00:08:37.385 --> 00:08:40.890
下一個章節我們會討論
例外處理

